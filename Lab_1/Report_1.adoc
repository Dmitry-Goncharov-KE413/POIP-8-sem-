---
title: Отчёт по таймерам
---

:reproducible:

:description: Report_1
:keywords: AsciiDoc
:imagesdir: ImgReport_1
:figure-caption: Рисунок
:table-caption: Таблица


:toc-title: Содержание
:toc:

[text-right]
--
Выполнил:
студент группы КЭ-413
Д.А. Гончаров
--
[.notes]
Таймером называется программный объект, осуществляющий пересчет значений времени с каждым тактом
до определенного значения, являющегося максимальным, после чего происходит сброс таймера.


== Системный таймер

Системный таймер, например, TIM1, имеет 3 регистра:

1. Регистр VAL, осуществляющий включение либо выключение таймера.
2. Регистр LOAD, в который записывается значение, до которого будет считать таймер.
3. Регистр CTRL текущего значения, в который записывается значение, с которого начинает считать таймер.

=== Алгоритм подключения и настройки системного таймера

1. Записать в регистре LOAD значение задержки, предварительно его рассчитав.
2. Записать в текущее значение счетчика в регистр VAL - "0", для сброса счётчика.
3. Подключить системный таймер к частоте процессора в регистре CTRL ().
4. Включить системный таймер в регистре CTRL.
5. Дождаться готовности флага COUNTFLAG в регистре CTRL.

По заданному алгоритму подключим таймер к проекту "Гирлянда".
Сперва необходмо подключить библиотеку в файл *main.cpp* для работы с регистрами системного таймера.

.Файл main.cpp
[source, c++]
-------
#include "stkregisters.hpp" // Описание регистров системного таймера
-------

Для того чтобы появилась возможность передать в функцию задержки Delay() значение задержки в мс
добавим в код константы:


.Файл main.cpp
[source, c++]
-------
#include "stkregisters.hpp" // Описание регистров системного таймера
constexpr std::uint32_t SystemClock = 8'000'000U; // тактирование внутреннего генератора
constexpr std::uint32_t OneMillisecondRation = 1000U; // коэффициент деления
-------

Изначально использованная в проекте "Garland" функция Delay() имела предназначение в задании определенного
значения задержки. Однако, поскольку в течение выполнения функции Delay() в программе отсутствовала возможность
выполнения любых других действий, следовательно, на ее выполнение затрачивалось гораздо больше времени, было принято
решение использовать таймеры.

.Функция задержки - Delay()
[source, c++]
-------
// -------------------------Function of Delay-----------------------------------
void Delay(uint64_t value)
{
  for(uint64_t i = 0;i<value;++i)
  {
    volatile uint64_t j = i;
  }
}
//------------------------------------------------------------------------------
-------

Реализуем функцию задержки через таймер. Следуя приведенной последовательности действий, сперва запишем в регистр LOAD
значение, до которого таймер будет считать, для чего рассчитаем требуемое значение задержки в переменной *delayCounts*.
Следующим шагом настроим таймер, сбросим его значение пересчета в ноль и запишем в регистр *LOAD* рассчитанное значение.
Впоследствии включим таймер, и он будет считать до заданного значения в мс. После того, как таймер досчитает до
максимального значения, программа выйдет из цикла и таймер выключится.

.Функция задержки - Delay()
[source, c++]
-------
// -------------------------Function of Delay-----------------------------------
void Delay(std::uint32_t milliseconds) // milliseconds - передаём требуемое количество миллисекунд для задержки
{
  const std::uint32_t delayCounts = milliseconds * SystemClock / OneMillisecondRation - 1U; // Расчёт значения таймера

//--------------Настройка таймера---
  STK::VAL::Write(0U);            // Сброс счётчика в "0"
  STK::LOAD::Write(delayCounts); // STK - модуль таймера, LOAD - регистр, в который записываем (Write(значение до которого считает счётчик))
//---------------------------------

  STK::CTRL::ENABLE::Enable::Set(); // Включение таймера
  while(!STK::CTRL::COUNTFLAG::Overflow::IsSet())
  {
     // InterruptPending – indicator of reaching of Timer 2 the maximum value (ARR)
  }
  STK::CTRL::ENABLE::Disable::Set(); // Выключение таймера
}
//------------------------------------------------------------------------------
-------

Таким образом, в функцию Delay() приходит значение задержки в мс, которое впоследствии пересчитывается в
переменной *delayCounts* и записывается в регистр *LOAD* таймера.

== Таймер TIM2

Таймер TIM2 не является системным таймером, т.е. составляющей ядра процессора, а уже периферией от производителя.
Данный таймер, как и системный TIM1, является 32-битным.
Данный таймер, наравне с таймером TIM5 общего назначения, имеет функции:

* Переполнение: событие по переполнению значения таймера.
* Захват сигнала (защелка): таймер защелкивает изменение значения, записывая значение таймера, когда произошло
это изменение.
* Сравнение: используется для задания периода.
* Событие-триггер: по истечении определённого значения таймера запускается другая периферия (АЦП, ШИМ).

=== Алгоритм подключения и настройки таймера TIM2 для реализации задержки

1. Подать тактирование на модуль таймера через *RCC::APB1ENR*.
2. Установить делитель частоты для таймера в регистре *PSС*.
3. Установить источник генерации прерываний по событию переполнение с помощью бита *URS* в регистре *CR1*.
4. Установить значение, до которого счетчик будет считать в регистре перезагрузке *ARR*.
5. Скинуть флаг генерации прерывания *UIF* по событию в регистре *SR*.
6. Установить начальное значение счетчика в "0" в регистре *CNT*.
7. Запустить счетчик с помощью бита *EN* в регистре *CR1*.
8. Проверять пока не будет установлен флаг генерации прерывания по событию *UIF* в регистре *SR*.
9. Как только флаг установлен остановить счетчик, сбросить бит *СEN* в регистре *CR1*, Сбросить флаг генерации прерывания *UIF* по событию в регистре *SR*.

=== Задание

По заданию требуется в функции Delay() заменить системный таймер на таймер TIM2.
По причине того, что таймер не является частью ядра процессора, его необходимо подключать к тактовой шине.
Для этого в функции *main* запишем следующий программный код:

.Задержка по таймеру TIM2
[source, c++]
-------
#include "tim2registers.hpp"  // Подключение таймера ТIM2

// -------------------------Функция задержки-----------------------------------
void Delay(std::uint32_t milliseconds)
{
  //--------------Настройка таймера
  TIM2::CNT::Write(0U);            // reset of Counter (CNT) to zero
  TIM2::ARR::Write(milliseconds);  // maximum value in Timer 2
  //------------------------------

  TIM2::CR1::CEN::Enable::Set();     // Включение таймера
  while(!TIM2::SR::UIF::InterruptPending::IsSet())
  {
     // InterruptPending – indicator of reaching of Timer 2 the maximum value (ARR)
  }
  TIM2::SR::UIF::NoInterruptPending::Set();
  TIM2::CNT::Write(0U);
  TIM2::CR1::CEN::Disable::Set(); // Выключение таймера
}
//------------------------------------------------------------------------------

int main()
{
  RCC::APB1ENR::TIM2EN::Enable::Set();             // submitting the clock for Timer 2
  TIM2::PSC::Write(8000U);                         // set the Prescaller (PSC) for frequency of Timer 2

  RCC::AHB1ENR::GPIOCEN::Enable::Set();

  //Порт С перевести в режим вывода (С.6 С.7 С.8 С.9 - линии светодиодов)
  GPIOC::MODER::MODER6::Output::Set();
  GPIOC::MODER::MODER7::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();
  userButton1.AddObserver(garland);

  for(;;)  // вечный цикл
  {
    userButton1.IsPressed() ;// Если кнопка нажата
    Delay(500); // в миллисекундах
    garland.UpdateCurrentMode(); // обновляем текущий режим светодиодов
  }
}
-------
== Вывод
В ходе работы осуществлены следующие основные этапы:

1. Ознакомление с основами применения системного таймера TIM1 и таймера общего
назначения TIM2.
2. Изменение ранее использованной в проекте функции задержки Delay() на функцию с использованием таймера TIM2.
3. Проверка работы модернизированной проекта "Garland", в результате чего было выявлено, что программа осуществляет
требуемое функционирование.